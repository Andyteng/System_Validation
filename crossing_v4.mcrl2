sort
 	% Multi-Objects
	SSensor 	= struct S1_e | S1_w | S2_e | S2_w;		% Side train detector sensors
	StopSign = struct ST1_e | ST1_w | ST2_e | ST1_train | ST2_train;  
	MSensor 	= struct S1_trian | S2_train;	% Center train detector sensors
	Light   	= struct L1 | L2;
	Barrier 	= struct B1 | B2;
	Track  	= struct T1 | T2;
	
	% States
	State 		= struct ON | OFF;	% Lights, Bell
	TrState   	= struct FREE | BUSY;      % track
	SigState 	= struct SEND | NOTSEND; 	% bell_sig, bell_status, barrier_sig, barrier_status (signal state)
	barState 	= struct OPEN | CLOSE;	% Barriers 
	sensorState	= struct DETECTED | UNDETECTED; % Sensors 
	
	% Current action state
	Changing = struct CHANGING | STATIC;

map	%Track is safe
	isFree: TrState # TrState -> Bool;
	
eqn
	isFree (FREE, FREE) = true; 
	isFree (BUSY, FREE) = false;
	isFree (FREE, BUSY) = false;
	isFree (BUSY, BUSY) = false; 
act 

	% External interactions
	% action
	Barriers	: barState;
	Lights	: Bool;
	Bell	: Bool;
	
	%sensors
	S1_e : sensorState;
	S1_w : sensorState;
	S2_e : sensorState;
	S2_w : sensorState;
	S1_train: sensorState;
	S2_train: sensorState;
	setSSensor	: SSensor # sensorState;
	setMSensor	: MSensor # sensorState;
	
 
 	%Internal interactions
	%actions 
 	barrier_status: SigState;
	setTrState: Track # TrState;

	%comm
	lights_sig_s: barState;
	lights_sig_r: barState;
	lights_sig: barState;

	bell_status_s: Bool;
	bell_status_r: Bool;
	bell_status: Bool;

	bell_sig_s: Bool;
	bell_sig_r: Bool;
	bell_sig: Bool;

	barrier_sig_s: Bool;
	barrier_sig_r: Bool;
	barrier_sig: Bool;
	
	barrier_status_s: Bool;
	barrier_status_r: Bool;
	barrier_status: Bool;

	
		

proc 

	Signal_Controller(st1_e, st1_w, st2_e, st2_w: sensorState, st1_train, st2_train: sensorState, state: barState) = 
		
		%System is FREE unless there is no train on both crossing
		(st1_e == UNDETECTED && st1_w == UNDETECTED && st2_e == UNDETECTED && st2_w == UNDETECTED) ->
		%System is FREE
		(state == CLOSE) ->
		% send a open signal and set state to open
		lights_sig_s(OPEN).Signal_Controller(state = OPEN)

		%Sensors & send a signal to tell the system is busy
		+ sum i: sensorState . (st1_e != i && i == DETECTED) -> S1_e(i). lights_sig_s(CLOSE) . Signal_Controller(st1_e = i, state = CLOSE)
		<> (st1_e != i && i == UNDETECTED) -> S1_e(i) . Signal_Controller(st1_e = i)

		+ sum i: sensorState . (st1_w != i && i == DETECTED) -> S1_w(i). lights_sig_s(CLOSE) . Signal_Controller(st1_w = i, state = CLOSE)
		<> (st1_w != i && i == UNDETECTED) -> S1_w(i) . Signal_Controller(st1_w = i)

		+ sum i: sensorState . (st2_e != i && i == DETECTED) -> S2_e(i). lights_sig_s(CLOSE) . Signal_Controller(st2_e = i, state = CLOSE)
		<> (st2_e != i && i == UNDETECTED) -> S2_e(i) . Signal_Controller(st2_e = i)

		+ sum i: sensorState . (st2_w != i && i == DETECTED) -> S2_w(i). lights_sig_s(CLOSE) . Signal_Controller(st2_w = i, state = CLOSE)
		<> (st2_w != i && i == UNDETECTED) -> S2_w(i) . Signal_Controller(st2_w = i)

;

	

Light_Controller(ls_sig: barState, bl_sig: Bool, bl_status: Bool, ls_on: Bool) = 
	
	% If both signals are off, then we turn off the lights.
	(ls_sig == OPEN && bl_status == false) ->
	%lights could only be turned off while it is on
	((ls_on == true) -> Lights(false). Light_Controller(ls_on = false))
	
	% Input signals & send a signal to turn on the lights
	+ sum i: barState . (ls_sig != i && i == CLOSE) -> 
	% Lights could only be turned on while it is off
	((ls_on == false) -> lights_sig_r(CLOSE) . Lights(true) . bell_sig_s(true) . Light_Controller(ls_sig = i, ls_on = true))
	<> (ls_sig != i && i == OPEN) -> lights_sig_r(OPEN) . bell_sig_s(false) . Light_Controller(ls_sig = i)
	% To receive the signal from bell_status
	+ sum i: Bool . (bl_status != i) -> bell_status_r(i) . Light_Controller(bl_status = i)
;
	
	
Bell_Controller(bl_sig: Bool, br_sig: Bool, br_status: Bool, bl_on: Bool) = 

	% If both signals are off, then we turn off the bell.
	(bl_sig == false && br_status == false) ->
	%bell could only be turned off while it is on
	((bl_on == true) -> Bell(false). Bell_Controller(bl_on = false))
	
	% Input signals & send a signal to turn on the bell
	+ sum i: Bool . (bl_sig != i && i == true) -> 
	% Bell could only be turned on while it is off
	(bl_on == false) -> bell_sig_r(true) . Bell(i) . barrier_sig_s(i) . Bell_Controller(bl_sig = i, bl_on = true)
	<> (bl_sig != i && i == false) -> bell_sig_r(false) . barrier_sig_s(i) . Bell_Controller(bl_sig = i)
	% To receive the signal from bell_status
	+ sum i: Bool . (br_status != i) -> barrier_status_r(i) . Bell_Controller(br_status = i)
;

Barrier_Controller(br_sig: Bool, br_status: Bool, br_on: barState) = 

	% If br_sig is off, then we OPEN Barriers.
	(br_sig == false) ->
	%barriers could only be opened while it is CLOSE
	(br_on == CLOSE) -> Barriers(OPEN). Barrier_Controller(br_on = OPEN)
	
	% Input signal & send a signal to close bell
	+ sum i: Bool . (br_sig != i && i == true) -> 
	% Barriers could only be closed while it is open
	((br_on == OPEN) -> barrier_sig_r(i) . Barriers(CLOSE) . barrier_status_s(true) . Barrier_Controller(br_sig = i, br_on = CLOSE))
	<> (br_sig != i && i == false) -> barrier_sig_r(i) . Barrier_Controller(br_sig = i)
;

init 

	allow (
		{lights_sig, S1_w, S1_e, S2_w, S2_e, Lights, Bell, Barriers, setTrState, barrier_sig, barrier_status, bell_sig, bell_status},
	comm (
	{lights_sig_s|lights_sig_r -> lights_sig, 
	bell_sig_s|bell_sig_r -> bell_sig,
	bell_status_s|bell_status_r -> bell_status, 
	barrier_status_s|barrier_status_r -> barrier_status,
	barrier_sig_s|barrier_sig_r -> barrier_sig
	},
	Signal_Controller(UNDETECTED, UNDETECTED, UNDETECTED, UNDETECTED, UNDETECTED, UNDETECTED, OPEN) 
	|| Light_Controller(OPEN, false, false,false)
	|| Bell_Controller(false, false, false,false)
	|| Barrier_Controller(false,false,OPEN)

));


	
